(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(throw {:msg "error"})
{:msg "error"}
(throw {:msg "error"})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(prn "something")
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" (deref exc)) 7)))
(try* (throw "my exception") (catch* exc (do (prn exc) 7)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(throw "my exception")
(def! a "my exception")
(throw a)
(throw "my exception")
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(readline "mal-user> ")
(= "something bogus" *host-language*)
(def! e (atom {"+" +}))
(swap! e assoc "-" -)
( (get @e "+") 7 8)
( (get @e "-") 11 8)
(swap! e assoc "foo" (list))
(get @e "foo")
(swap! e assoc "bar" '(1 2 3))
(get @e "bar")
(do (list time-ms string? number? seq conj meta with-meta fn?) nil)
(meta (fn* (a) a))
(meta (with-meta (fn* (a) a) {"b" 1}))
(+ 1 2)
test
(+ 1 2)
(1 2)
(+ 1 2)
(1 2)
(2 3)
(conj [1 2 3])
(seq [1 2 3])
(seq "test")
(meta "test")
(with-meta "test" "Dies Irae")
(with-meta [] "Dies Irae")
(with-meta "test" "Dies Irae")
(def! shit (fn* (a) a))
(with-meta shit "test")
(def! shit (fn* (a) a))
(with-meta shit "test")
(def! shit (fn* (a) a))
(with-meta shit "test")
(def! shit (fn* (a) a))
(with-meta shit "test")
(def! sshit (with-meta shit "test"))
(meta sshit)
^sshit "test"
(def! shit (fn* (a) a))
^"test" sshit
^"test" shit
(meta ^"test" shit)
(conj [1 2] 3)
(conj 3 [1 2])
(citron-eval "123")
(citron-eval "call/cc")
(+ 1 2)
(/ (- (+ 5 (* 2 3)) 3) 4)
(def! x 3)
x
(def! x 4)
x
(def! y (+ 1 7))
y
(def! mynum 111)
(def! MYNUM 222)
mynum
MYNUM
(abc 1 2 3)
(def! w 123)
(def! w (abc))
w
(let* (z 9) z)
(let* (x 9) x)
x
(let* (z (+ 2 3)) (+ 1 z))
(let* (p (+ 2 3) q (+ 2 p)) (+ p q))
(def! y (let* (z 7) z))
y
(def! a 4)
(let* (q 9) q)
(let* (q 9) a)
(let* (z 2) (let* (q 9) a))
(let* [z 9] z)
(let* [p (+ 2 3) q (+ 2 p)] (+ p q))
(let* (a 5 b 6) [3 4 a [b 7] 8])
(let* (a 5 b 6) [3 4 a [b 7] 8]
(let* (a 5 b 6) [3 4 a [b 7] 8][
(let* (a 5 b 6) [3 4 a [b 7] 8]]
(let* (a 5 b 6) [3 4 a [b 7] 8])
(def! test (fn* (a & b) (str a [b])))
(test 1 2 3 4 5)
djÙ
readline
(readline "Who out there? ")
(keyword? :x)
:x
\x
(def! \x :
(def! \x :x
(def! \x :x)
\x
123
(+ 1 (+ 2 3))
(+ 1 2 3)
(macro? {})
(macroexpand '())
(macroexpand ())
(macro? macro?)
(fn? macroexpand)
(fn? macro?)
