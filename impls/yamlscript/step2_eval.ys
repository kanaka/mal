!YS-v0
use readline: :all
use reader: :all
use printer: :all

# EVAL extends this stack trace when propagating exceptions.
# If the exception reaches the REPL loop, the full trace is printed.
trace =: atom('')

# read
READ =: read-str

# eval
defn EVAL(ast env):
  # prn: "EVAL: $ast"
  try:
    if ast:symbol?:
      or env.get(ast:str):
        die: "$ast not found"
      condf ast:
        map?:
          reduce-kv _ {} ast:
            fn(map key val):
              assoc map: EVAL(key env) EVAL(val env)
        vector?:
          reduce _ [] ast:
            fn(vec node):
              conj vec: EVAL(node env)
        list?:
          if ast:empty?:
            then: list()
            else:
              func =: EVAL(ast:first env)
              args =: ast:rest
              if func:fn?:
                apply func:
                  map \(EVAL(_ env)): args
                die: 'can only apply functions'
        set?: die("EVAL($ast) not yet supported")
        else: ast
    catch exc:
      reset trace: "\n  in mal EVAL: $ast"
      die: exc

# print
PRINT =: \(prStr(_ true))

# repl
repl-env =:
  hash-map: +
    '+' +
    '-' -
    '*' *
    '/' quot

defn rep(strng):
  strng:READ.EVAL(repl-env):PRINT

# repl loop
defn repl-loop(line=''):
  when line:
    when line != '':
      try:
        say: rep(line)
        catch exc:
          say: "Uncaught exception: $exc"
    repl-loop: readline('mal-user> ')

# main
defn main(): repl-loop()
