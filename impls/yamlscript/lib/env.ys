!YS-v0
ns: env

# XXX ys bug workaround
declare: env-find-str

# An environment is an atom referencing a map where keys are strings instead of
# symbols. The outer environment is the value associated with the normally
# invalid :outer key.

# Private helper for new-env.
defn bind-env(env b e):
  if b:empty?:
    if e:empty?:
      then: env
      else:
        die: 'too many arguments in function call'
    else:
      b0 =: b:first
      if b0 == q(&):
        if b.# == 2:
          if b.1:symbol?:
            assoc env: b.1:str e
            die: 'formal parameters must be symbols'
          die: "misplaced '&' construct"
        if e:empty?:
          die: 'too few arguments in function call'
          if b0:symbol?:
            bind-env: assoc(env b0:str e:first) b:rest e:rest
            die: 'formal parameters must be symbols'

defn new-env(*args):
  if args.# <= 1:
    atom({:outer args:first})
    atom(apply(bind-env {:outer args:first} args:rest))

defn env-as-map(env):
  dissoc env.@: :outer

defn env-get-or-nil(env k):
  when k:symbol?: die("env-get-or-nil '$k' is a symbol")
  e =: env.env-find-str(k)
  when e: e.@.get(k)

# Private helper for env-get and env-get-or-nil.
defn env-find-str(env k):
  when env:
    data =: env.@
    if contains?(data k):
      env
      env-find-str(data.get(:outer) k)

defn env-get(env k):
  when k:symbol?: die("env-get '$k' is a symbol")
  e =: env-find-str(env k)
  if e:
    get e.@: k
    die: "'$k' not found"

defn env-set(env k v):
  when k:symbol?: die("env-set '$k' is a symbol")
  swap env: assoc k v
