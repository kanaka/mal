!YS-v0
use readline: :all
use reader: :all
use printer: :all
use env: :all

# EVAL extends this stack trace when propagating exceptions.
# If the exception reaches the REPL loop, the full trace is printed.
trace =: atom('')

# read
READ =: read-str

# eval
defn LET(env binds form):
  if binds:empty?:
    EVAL: form env
    if (binds.# >= 2) && binds.0:symbol?:
      then:
        env-set env binds.0:str: EVAL(binds.1 env)
        LET env: binds:rest:rest form
      else: die("invalid binds")

defn EVAL(ast env):
  when env-get-or-nil(env 'DEBUG-EVAL'):
    say: +"EVAL:" pr-str(ast) pr-str(env-as-map(env))
  try:
    condf ast:
      symbol?: env-get(env ast:str)
      vector?:
        ast.map(\(EVAL(_ env))):vec
      map?:
        apply hash-map: ast:seq:flatten.map(\(EVAL _ env))
      list?:
        if ast:empty?:
          list:
          else:
            a0 =: ast:first
            condp eq a0:
              symbol('def!'):
                if (ast.# == 3) && ast.1:symbol?:
                  then:
                    val =: EVAL(ast.2 env)
                    env-set env: ast.1:str val
                    =>: val
                  else:
                    die: 'bad arguents'
              symbol('let*'):
                if (ast.# == 3) && ast.1:sequential?:
                  LET new-env(env): ast.1 ast.2
                  die: 'bad arguents'
              else:
                f =: EVAL(a0 env)
                args =: ast:rest
                if f:fn?:
                  apply f: args.map(\(EVAL(_ env))):vec
                  die: 'can only apply functions'
      set?: die("EVAL($ast) not yet supported")
      else: ast
    catch exc:
      reset trace: "\n  in mal EVAL: $ast"
      die: exc

# print
PRINT =: \(prStr(_ true))

repl-env =: new-env()

env-set: repl-env '+' +
env-set: repl-env '-' -
env-set: repl-env '*' *
env-set: repl-env '/' quot

defn rep(strng):
  strng:READ.EVAL(repl-env):PRINT

# repl loop
defn repl-loop(line=''):
  when line:
    when line != '':
      try:
        say: rep(line)
        catch exc:
          say: "Uncaught exception: $exc"
    repl-loop: readline('mal-user> ')

# main
defn main(): repl-loop()
