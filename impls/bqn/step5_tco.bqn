âŸ¨nilâŸ© â† â€¢Import "globals.bqn"
âŸ¨EnvâŸ© â† â€¢Import "env.bqn"
âŸ¨ReadStrâŸ© â† â€¢Import "reader.bqn"
âŸ¨PrStrRâŸ© â† â€¢Import "printer.bqn"
âŸ¨coreâŸ© â† â€¢Import "core.bqn"

EvalAst â† {env ğ•Š tâ€¿v:
  {0: env.Get v ;
   3: envâŠ¸EVALÂ¨v ;
   tâ€¿v
  }t
}

SetParams â† {env ğ•Š argsâ€¿xs:
  {ğ•Š
    {0â€¿"&": env.Set (<1âŠ‘1âŠ‘args)âˆ¾<3âˆ¾<env EVALÂ¨xs â‹„ argsâ†©âŸ¨âŸ©;
     0â€¿kw: env.Set (<kw)âˆ¾<env EVAL âŠ‘xs}âŠ‘args
    args 1âŠ¸â†“â†©
    xs 1âŠ¸â†“â†©
  }â€¢_while_{ğ•Š â‹„ 0<â‰ args}@
}

READ â† ReadStr
PRINT â† PrStrR
EVAL â† {e ğ•Š ast:
  # this loop runs as long as @ is returned, ie. typically once
  {ğ•Š â‹„ {
    # builtin special forms
    ğ•Š 3â€¿âŸ¨0â€¿"def!",0â€¿k,xâŸ©:
      v â† e EVAL x
      {Â¯1:@;e.Set (<k)âˆ¾<v}âŠ‘v
      v ;
    ğ•Š 3â€¿âŸ¨0â€¿"let*",tâ€¿binds,expâŸ©:
      inner â† Env e
      {ğ•Š
        {âŸ¨0â€¿kw,xâŸ©: inner.Set (<kw)âˆ¾<inner EVAL x}2â†‘binds
        binds 2âŠ¸â†“â†©
      }â€¢_while_{ğ•Š â‹„ 0<â‰ binds}@
      e â†© inner
      ast â†© exp
      @;
    ğ•Š 3â€¿âŸ¨0â€¿"if",c,t,fâŸ©:
      ast â†© {8â€¿x:f; 7â€¿0:f; t} e EVAL c
      @;
    ğ•Š 3â€¿âŸ¨0â€¿"if",c,tâŸ©:
      ast â†© {8â€¿x:nil; 7â€¿0:nil; t} e EVAL c
      @;
    ğ•Š 3â€¿âŸ¨0â€¿"fn*",tâ€¿args,expâŸ©:
      10â€¿expâ€¿argsâ€¿eâ€¿{ğ•Š xs:
        inner â† Env e
        inner SetParams argsâ€¿xs
        inner EVAL exp} ;

    # variable-length special forms
    ğ•Š 3â€¿âŸ¨âŸ©: 3â€¿âŸ¨âŸ© ;
    ğ•Š 3â€¿xs:{
      0â€¿"do":
        eâŠ¸EVALÂ¨Â¯1â†“1â†“xs
        ast â†© Â¯1âŠ‘xs
        @
      ; ys â† e EvalAst 3â€¿xs          # function application
        f â† âŠ‘ys
        {9â€¿f: F 1â†“ys ;
         10â€¿expâ€¿argsâ€¿e2â€¿fn:
           ast â†© exp
           e â†© Env e2
           e SetParams argsâ€¿(1â†“ys)
           @;
         Â¯1â€¿x: f;
         Â¯1âˆ¾<"not a function: "âˆ¾PrStrR f} f
      }âŠ‘xs ;

    # basic forms
    ğ•Š 4â€¿xs: 4âˆ¾<eâŠ¸EVALÂ¨xs ;
    ğ•Š 5â€¿xs: 5âˆ¾<eâŠ¸EVALÂ¨xs ;
    ğ•Š x: e EvalAst x
  } ast
}â€¢_while_{ğ•©â‰¡@}@}

Rep â† PRINTâˆ˜{core EVAL ğ•©}âˆ˜READ

Rep "(def! not (fn* (a) (if a false true)))"

{
  â€¢Out "user> "
  line â† â€¢GetLine 0
  â€¢Out Rep line
  ğ•Šğ•©
}@
