âŸ¨EnvâŸ© â† â€¢Import "env.bqn"
âŸ¨ReadStr,nilâŸ© â† â€¢Import "reader.bqn"
âŸ¨PrStrâŸ© â† â€¢Import "printer.bqn"
âŸ¨coreâŸ© â† â€¢Import "core.bqn"

EvalAst â† {env ğ•Š tâ€¿v:
  {0: env.Get v ;
   3: envâŠ¸EVALÂ¨v ;
   tâ€¿v
  }t
}

READ â† ReadStr
PRINT â† PrStr
EVAL â† {e ğ•Š ast:
  # this loop runs as long as @ is returned, ie. typically once
  {ğ•Š â‹„ {
    # builtin special forms
    ğ•Š 3â€¿âŸ¨0â€¿"def!",0â€¿k,xâŸ©:
      v â† e EVAL x
      {Â¯1:@;e.Set (<k)âˆ¾<v}âŠ‘v
      v ;
    ğ•Š 3â€¿âŸ¨0â€¿"let*",tâ€¿binds,expâŸ©:
      inner â† Env e
      {ğ•Š
        {âŸ¨0â€¿kw,xâŸ©: inner.Set (<kw)âˆ¾<inner EVAL x}2â†‘binds
        binds 2âŠ¸â†“â†©
      }â€¢_while_{ğ•Š â‹„ 0<â‰ binds}@
      e â†© inner
      ast â†© exp
      @;
    ğ•Š 3â€¿âŸ¨0â€¿"if",c,t,fâŸ©:
      ast â†© {8â€¿x:f; 7â€¿0:f; t} e EVAL c
      @;
    ğ•Š 3â€¿âŸ¨0â€¿"if",c,tâŸ©:
      ast â†© {8â€¿x:nil; 7â€¿0:nil; t} e EVAL c
      @;
    ğ•Š 3â€¿âŸ¨0â€¿"fn*",tâ€¿args,expâŸ©:
      9â€¿{ğ•Š xs:
        as â† args
        inner â† Env e
        {ğ•Š
          {0â€¿"&": inner.Set (<1âŠ‘1âŠ‘as)âˆ¾<3âˆ¾<inner EVALÂ¨xs â‹„ asâ†©âŸ¨âŸ©;
           0â€¿kw: inner.Set (<kw)âˆ¾<inner EVAL âŠ‘xs}âŠ‘as
          as 1âŠ¸â†“â†©
          xs 1âŠ¸â†“â†©
        }â€¢_while_{ğ•Š â‹„ 0<â‰ as}@
        inner EVAL exp} ;

    # variable-length special forms
    ğ•Š 3â€¿âŸ¨âŸ©: 3â€¿âŸ¨âŸ© ;
    ğ•Š 3â€¿xs:{
      0â€¿"do":
        eâŠ¸EVALÂ¨Â¯1â†“1â†“xs
        ast â†© Â¯1âŠ‘xs
        @
      ; ys â† e EvalAst 3â€¿xs          # function application
        f â† âŠ‘ys
        {9â€¿f: F 1â†“ys ;
         Â¯1â€¿x: f;
         Â¯1âˆ¾<"not a function: "âˆ¾PrStr f} f
      }âŠ‘xs ;

    # basic forms
    ğ•Š 4â€¿xs: 4âˆ¾<eâŠ¸EVALÂ¨xs ;
    ğ•Š 5â€¿xs: 5âˆ¾<eâŠ¸EVALÂ¨xs ;
    ğ•Š x: e EvalAst x
  } ast
}â€¢_while_{ğ•©â‰¡@}@}

Rep â† PRINTâˆ˜{core EVAL ğ•©}âˆ˜READ

{
  â€¢Out "user> "
  line â† â€¢GetLine 0
  â€¢Out Rep line
  ğ•Šğ•©
}@
