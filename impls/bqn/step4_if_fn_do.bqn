âŸ¨nilâŸ© â† â€¢Import "globals.bqn"
âŸ¨EnvâŸ© â† â€¢Import "env.bqn"
âŸ¨ReadStrâŸ© â† â€¢Import "reader.bqn"
âŸ¨PrStrRâŸ© â† â€¢Import "printer.bqn"
âŸ¨coreâŸ© â† â€¢Import "core.bqn"

EvalAst â† {env ğ•Š tâ€¿v:
  {0: env.Get v ;
   3: envâŠ¸EVALÂ¨v ;
   tâ€¿v
  }t
}

READ â† ReadStr
PRINT â† PrStrR
EVAL â† {
  # builtin special forms
  env ğ•Š 3â€¿âŸ¨0â€¿"def!",0â€¿k,xâŸ©:
    v â† env EVAL x
    {Â¯1:@;env.Set (<k)âˆ¾<v}âŠ‘v
    v ;
  outer ğ•Š 3â€¿âŸ¨0â€¿"let*",tâ€¿binds,expâŸ©:
    inner â† Env outer
    {ğ•Š
      {âŸ¨0â€¿kw,xâŸ©: inner.Set (<kw)âˆ¾<inner EVAL x}2â†‘binds
      binds 2âŠ¸â†“â†©
    }â€¢_while_{ğ•Š â‹„ 0<â‰ binds}@
    inner EVAL exp ;
  env ğ•Š 3â€¿âŸ¨0â€¿"if",c,t,fâŸ©:
    env EVAL {8â€¿x:f; 7â€¿0:f; t} env EVAL c ;
  env ğ•Š 3â€¿âŸ¨0â€¿"if",c,tâŸ©:
    env EVAL {8â€¿x:nil; 7â€¿0:nil; t} env EVAL c ;
  outer ğ•Š 3â€¿âŸ¨0â€¿"fn*",tâ€¿args,expâŸ©:
    9â€¿{ğ•Š xs:
      as â† args
      inner â† Env outer
      {ğ•Š
        {0â€¿"&": inner.Set (<1âŠ‘1âŠ‘as)âˆ¾<3âˆ¾<inner EVALÂ¨xs â‹„ asâ†©âŸ¨âŸ©;
         0â€¿kw: inner.Set (<kw)âˆ¾<inner EVAL âŠ‘xs}âŠ‘as
        as 1âŠ¸â†“â†©
        xs 1âŠ¸â†“â†©
      }â€¢_while_{ğ•Š â‹„ 0<â‰ as}@
      inner EVAL exp} ;

  # variable-length special forms
  env ğ•Š 3â€¿âŸ¨âŸ©: 3â€¿âŸ¨âŸ© ;
  env ğ•Š 3â€¿xs:{
    0â€¿"do": Â¯1âŠ‘envâŠ¸EVALÂ¨1â†“xs
    ; ys â† env EvalAst 3â€¿xs          # function application
      f â† âŠ‘ys
      {9â€¿f: F 1â†“ys ;
       Â¯1â€¿x: f;
       Â¯1âˆ¾<"not a function: "âˆ¾PrStrR f} f
    }âŠ‘xs ;

  # basic forms
  env ğ•Š 4â€¿xs: 4âˆ¾<envâŠ¸EVALÂ¨xs ;
  env ğ•Š 5â€¿xs: 5âˆ¾<envâŠ¸EVALÂ¨xs ;
  env ğ•Š x: env EvalAst x
}
Rep â† PRINTâˆ˜{core EVAL ğ•©}âˆ˜READ

Rep "(def! not (fn* (a) (if a false true)))"

{
  â€¢Out "user> "
  line â† â€¢GetLine 0
  â€¢Out Rep line
  ğ•Šğ•©
}@
